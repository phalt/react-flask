{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcab Beckett framework","text":"<p>A strongly-linked Python &amp; Typescript Framework</p> <p></p> <p>Beckett framework is the fastest way to build a type-safe Python webserver and React TypeScript website with consistent typing interfaces in languages.</p> <p>Beckett bundles a Flask application and a React web server into one full stack framework, and tightly-couples the Typed API interface without the need for an intermediary domain language. At it's core, Beckett provides a types manager that keeps the Python Type hints and TypeScript interfaces in sync for you as you make changes. THis means that changes can be deployed confidentally without worrying if the API interface defintions in either language will drift - Beckett just won't let them.</p> <p>Because it is strongly-linked it also automatically provides <code>Props</code> to React pages from the Flask view linked to it.</p> <p>It is strongly opinionated, but it boosts productivity.</p>"},{"location":"configuration/","title":"\ud83d\udd27 Configuration","text":"<p>Beckett is heavily convention-based, yet you can configure quite a bit of it based on what your project set up needs.</p>"},{"location":"configuration/#settings","title":"Settings","text":"<p>All settings should be set as environment variables.</p>"},{"location":"configuration/#environment","title":"<code>ENVIRONMENT</code>","text":"<p>Default: <code>development</code></p> <p>When this variable is set to <code>development</code> in order to enable the Beckett hot-reloader and auto generation features.</p>"},{"location":"configuration/#beckett_metafile_path","title":"<code>BECKETT_METAFILE_PATH</code>","text":"<p>Defaut: <code>{pwd}/metafile.json</code></p> <p>The file tracks the manifest of React pages registered in the app, and enables hot-reloading in development. In production is provides a link between the Flask view function and the React page (because it will be generated with a hash that the Flask view function doesn't know about).</p>"},{"location":"configuration/#beckett_react_page_template","title":"<code>BECKETT_REACT_PAGE_TEMPLATE</code>","text":"<p>Default: <code>{pwd}/template/beckett_page.template</code></p> <p>This is the template used when generating new React pages.</p>"},{"location":"features/","title":"\ud83d\udcc4 Features","text":""},{"location":"features/#built-on-great-tools","title":"Built on great tools","text":"<p>Beckett bundles a Flask web server and a React TypeScript frontend into one framework.</p> <p>TypeScript and Python are two of the most used programming languages in the world, and so are often used together in projects. Despite this; getting them set up to work together nicely is tedious and time consuming, and often a poor developer experience.</p> <p>Beckett solves this problem by strongly-linking them together as one framework.</p>"},{"location":"features/#and-you-can-continue-to-use-them","title":"...and you can continue to use them","text":"<p>Beckett doesn't expect you to use Python to control the frontend, when React TypeScript offers a better solution, and vice versa.</p> <p>You still write Flask views like a normal flask app, and you can install and use any other Python library that works nicely with Flask.</p> <p>You still write React TypeScript like any other React application, and you can <code>yarn add</code> any JS library you like to meet the needs of your project.</p>"},{"location":"features/#strongly-linked-types","title":"Strongly-linked types","text":"<p>When we built Beckett we decided that if we're going to bundle the languages together, why not link them strongly and find extra benefits?</p> <p>The first major feature we built was strongly-linked types.</p> <p>Beckett takes your Python Typehints and auto-generates TypeScript interfaces to maintain type integrity across both languages. It does this automatically for any API endpoints in the Flask web server using the Beckett decorators.</p> src/views/people.py<pre><code>import attrs\nfrom src.app import app\nfrom src.beckett.blueprint import BeckettBlueprint\nfrom src.beckett.types import APIResponse\nblueprint = BeckettBlueprint(\"people\", __name__, url_prefix=\"/people\")\n@attrs.define\nclass GetPeopleResponse(APIResponse):\nname: str\n@blueprint.api_get(\"/get\")\ndef get_people() -&gt; GetPeopleResponse:\n\"\"\"\n    This is an example API GET route.\n    \"\"\"\nreturn GetPeopleResponse(name=\"Paul\")\napp.register_blueprint(blueprint)\n</code></pre> <p>When the Beckett flask server is running, this will autogenerate the following TypeScript interface:</p> js/api/types.ts<pre><code>/*\nTHIS FILE IS AUTO-GENERATED, DO NOT ALTER MANUALLY.\n*/\n// prettier-ignore\nexport interface PeopleGetPeopleResponse {\n\"__type__\": string\n\"__http_status_code__\": number\n\"name\": string\n}\n...\n</code></pre> <p>Beckett automatically adds additional parameters to any <code>APIResponse</code> object it such as <code>__type__</code> and <code>__http_status_code__</code>. Beckett's TypeScript API Client uses these fields to introspect the API response and handle errors gracefully for you.</p> <p>Under the hood, we use attrs and cattrs to take the types in the classes we define and transform them into their TypeScript equivalents.</p>"},{"location":"features/#react-pages","title":"React pages","text":"<p>Beckett will auto-generate any new React page when you register a new Beckett page in the Flask service, when you are in development mode. Beckett's is built such that a Flask route (defined through the URL of a Flask view function) can be linked directly to a React page on the frontend.</p> src/views/people.py<pre><code>import attrs\nfrom src.app import app\nfrom src.beckett.blueprint import BeckettBlueprint\nfrom src.beckett.renderer.typescript_react.renderer import beckett_page\nblueprint = BeckettBlueprint(\"people\", __name__, url_prefix=\"/people\")\n# Hiding other endpoints for clarity\n...\n@attrs.define\nclass ExamplePageProps:\nhello: str\n@blueprint.route(\"/\")\n@beckett_page()\ndef example_page() -&gt; ExamplePageProps:\nreturn ExamplePageProps(hello=\"world\")\napp.register_blueprint(blueprint)\n</code></pre> <p>When the Beckett Flask server is running in development mode it will recognise a new endpoint has been registered, and it makes a new React page linked to the Flask view. This is all handled by applying the <code>@beckett_page()</code> decorator.</p> <p>The generated page will start something like this:</p> src/js/template/people/example_page.tsx<pre><code>import React from 'react'\nimport PageProps from './example_page.type'\nimport {Container, Row} from 'react-bootstrap'\nconst Page: React.FunctionComponent&lt;PageProps&gt; = (props) =&gt; {\nreturn (\n&lt;Container&gt;\n&lt;Row className=\"mb-4 border-bottom\"&gt;\n&lt;h1&gt;Hello, React!&lt;/h1&gt;\n&lt;p&gt;\nhere are my props: &lt;code&gt;{props}&lt;/code&gt;\n&lt;/p&gt;\n&lt;/Row&gt;\n&lt;/Container&gt;\n)\n}\nexport default Page\n</code></pre> <p>The template can be customised by setting the <code>BECKETT_REACT_PAGE_TEMPLATE</code> environment variable to a path.</p> <p>Once this has been generated you are free to go and develop the frontend using any React library you want.</p>"},{"location":"features/#props-for-react-pages","title":"Props for React pages","text":"<p>As well as the base page, <code>beckett_page</code> also generates a <code>PageProps</code> interface. The response returned by the Flask view are injected as props into this page for you automatically. The generated file for the example above looks something like this:</p> src/js/template/people/example_page.type.ts<pre><code>// This file is generated by @beckett_page\n// prettier-ignore\nexport default interface PageProps {\n\"hello\": string\n}\n</code></pre> <p>This file will update automatically as you make changes to the Flask view response class and the server is in development mode.</p>"},{"location":"features/#api-client","title":"API Client","text":"<p>TODO</p>"},{"location":"features/#refresh-api-queries","title":"Refresh API queries","text":"<p>TODO</p>"},{"location":"features/#run-it-all-together-at-once","title":"Run it all together at once","text":"<p>Instead of maintaining multiple terminals running two different servers, Beckett provides a single development command to run both the Flask service and React server in development mode. Both are these run in \"hot reload\" - any code changes will restart each server so changes happen immediately.</p> <pre><code>make dev\n</code></pre>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":""},{"location":"types_conversion/","title":"\ud83c\udfb9 Types conversion","text":"<p>Remember! Beckett doesn't just convert one way.</p> <p>API requests going into the Beckett Flask service will be checked for type consistency.</p> <p>Beckett Framework uses Beckett types to manage types translation.</p>"},{"location":"types_conversion/#conversion-chart","title":"Conversion chart","text":"<p>We translate Python TypeHints into these TypeScript types, and vice versa:</p> Python TypeScript <code>str</code> <code>string</code> <code>int</code> <code>number</code> <code>float</code> <code>number</code> <code>decimal.Decimal</code> <code>number</code> <code>dict</code> <code>Record&lt;string, any&gt;</code>"},{"location":"types_conversion/#nested-types","title":"Nested types","text":"<p>Nested <code>attrs</code> classes are converted infinitely:</p> example.py<pre><code>@attrs.define\nclass Subclass:\nhello: str\n@attrs.define\nclass ExamplePageProps:\ntest: Subclass\n</code></pre> <p>Which generates:</p> types.ts<pre><code>// prettier-ignore\nexport interface Subclass {\n\"hello\": string\n}\n// prettier-ignore\nexport default interface PageProps {\n\"test\": Subclass\n}\n</code></pre>"}]}